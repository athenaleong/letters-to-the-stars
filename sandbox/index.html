<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/main.css">
    <title>Yay</title>
</head>


<body>

<script src="js/three.js"></script>
<script>

/** 
 * Class that handles translation based on mouse input 
 **/
class MouseControl {

    /**
     * constructor
     * @param {THREE.WebGLRenderer} renderer
     * @param {THREE.PerspectiveCamera} camera
     */
    constructor(renderer, camera) {

        const self = this;

        const v2 = new THREE.Vector2( );
        renderer.getDrawingBufferSize(v2);
        this.width = v2.x;
        this.height = v2.y;
        this.renderer = renderer;
        this.camera = camera;

        this._ratio = this.height / this.width;
        this._difftranslate = [null, null];

        this._diffwheel = 0;

        this._iswheel = false;
        this._wheeltimeout = null;

        this._ismousedown = false;
        this._mousedownpos = [0,0];
        this._mousepos = [null, null];

        renderer.domElement.addEventListener('mousemove', function (e) {
            if (self._ismousedown) {
                self._difftranslate = [
                    self._difftranslate[0] + e.pageX - self._mousepos[0], 
                    self._difftranslate[1] + e.pageY - self._mousepos[1]];
            }
            self._mousepos = [e.pageX, e.pageY];
        }, false);

        renderer.domElement.addEventListener('mousedown', function (e) {
            if (!self._ismousedown) {
                self._mousedownpos = [e.pageX, e.pageY];
            }
            self._ismousedown = true;
        }, false);

        renderer.domElement.addEventListener('mouseup', function (e) {
            self._ismousedown = false;
            self._difftranslate = [0,0];
        }, false);

        renderer.domElement.addEventListener("wheel", function(e) {
            clearTimeout(self._wheeltimeout);
            self._diffwheel += e.deltaY;
            self._iswheel = true;
            self._wheeltimeout = setTimeout(function(){self._iswheel = false;}, 250);
            
        }, false);
    }

    updataCamera() {

        var cpos = [
            this.camera.position.x,
            this.camera.position.y,
            this.camera.position.z
        ];

        // Implement translation
        if (this._ismousedown) {

            var [tx,ty] = this._difftranslate;
            var tx = tx/this.width;
            var ty = ty/this.width;
            this.camera.position.x -= tx * cpos[2];
            this.camera.position.y += ty * cpos[2];

            this._difftranslate = [0,0];
        }

        // Implement zoom
        if (this._iswheel) {

            var zoom = this._diffwheel;
            zoom /= this.height;
            zoom *= 2.;
            var [mx,my] = this._mousepos;
            var mx = mx/this.width - 0.5; // Scale to [-0.5, 0.5]
            var my = my/this.height - 0.5;
            my *= this._ratio
            
            //this.camera.position.x -= mx * cpos[2] * zoom * .4;
            //this.camera.position.y += my * cpos[2] * zoom * .4;
            this.camera.position.z += zoom;
            
            this._diffwheel = 0
        }

        this.camera.position.z = Math.max(0, this.camera.position.z);
    }
}

const renderer = new THREE.WebGLRenderer();
renderer.setClearColor(0xaaaaff);
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.z = 5;

var light1 = new THREE.AmbientLight(0xaaaaff, .5);
var light2 = new THREE.PointLight(0xaaaaff, 1.);
light2.position.y += 10;
scene.add(light1);
scene.add(light2);

const material = new THREE.MeshPhongMaterial();

const geometry = new THREE.BoxGeometry();
const cube1 = new THREE.Mesh(geometry, material);
cube1.position.x = 10;
const cube2 = new THREE.Mesh(geometry, material);
cube2.position.x = 0;
const cube3 = new THREE.Mesh(geometry, material);
cube3.position.x = -10;
const cube4 = new THREE.Mesh(geometry, material);
cube4.position.y = 10;
const cube5 = new THREE.Mesh(geometry, material);
cube5.position.y = -10;
const cube6 = new THREE.Mesh(geometry, material);
cube6.position.z = 10;
const cube7 = new THREE.Mesh(geometry, material);
cube7.position.z = -10;
scene.add(cube1);scene.add(cube4);
scene.add(cube2);scene.add(cube5);
scene.add(cube3);scene.add(cube6);scene.add(cube7);

const control = new MouseControl(renderer, camera); // Init mouse control

const animate = function () {
    requestAnimationFrame( animate );
    control.updataCamera();
    renderer.render( scene, camera );
};

animate();

</script>

</body>
</html>